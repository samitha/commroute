<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>networkx.linalg.attrmatrix</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://github.com/jackdreilly/commroute">CommRoute</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="networkx-module.html">Package&nbsp;networkx</a> ::
        <a href="networkx.linalg-module.html">Package&nbsp;linalg</a> ::
        Module&nbsp;attrmatrix
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="networkx.linalg.attrmatrix-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module attrmatrix</h1><p class="nomargin-top"><span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html">source&nbsp;code</a></span></p>
<p>Functions for constructing matrix-like objects from graph 
  attributes.</p>

<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="networkx.linalg.attrmatrix-module.html#_node_value" class="summary-sig-name" onclick="show_private();">_node_value</a>(<span class="summary-sig-arg">G</span>,
        <span class="summary-sig-arg">node_attr</span>)</span><br />
      Returns a function that returns a value from G.node[u].</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#_node_value">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="networkx.linalg.attrmatrix-module.html#_edge_value" class="summary-sig-name" onclick="show_private();">_edge_value</a>(<span class="summary-sig-arg">G</span>,
        <span class="summary-sig-arg">edge_attr</span>)</span><br />
      Returns a function that returns a value from G[u][v].</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#_edge_value">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="networkx.linalg.attrmatrix-module.html#attr_matrix" class="summary-sig-name">attr_matrix</a>(<span class="summary-sig-arg">G</span>,
        <span class="summary-sig-arg">edge_attr</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">node_attr</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normalized</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">rc_order</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>)</span><br />
      Returns a NumPy matrix using attributes from G.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#attr_matrix">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="networkx.linalg.attrmatrix-module.html#attr_sparse_matrix" class="summary-sig-name">attr_sparse_matrix</a>(<span class="summary-sig-arg">G</span>,
        <span class="summary-sig-arg">edge_attr</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">node_attr</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normalized</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">rc_order</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Returns a SciPy sparse matrix using attributes from G.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#attr_sparse_matrix">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="setup_module"></a><span class="summary-sig-name">setup_module</span>(<span class="summary-sig-arg">module</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#setup_module">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="'networkx.linalg'"><code class="variable-quote">'</code><code class="variable-string">networkx.linalg</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="_node_value"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">_node_value</span>(<span class="sig-arg">G</span>,
        <span class="sig-arg">node_attr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#_node_value">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Returns a function that returns a value from G.node[u].

We return a function expecting a node as its sole argument. Then, in the
simplest scenario, the returned function will return G.node[u][node_attr].
However, we also handle the case when `node_attr` is None or when it is a 
function itself.

Parameters
----------
G : graph
    A NetworkX graph 

node_attr : {None, str, callable}
    Specification of how the value of the node attribute should be obtained 
    from the node attribute dictionary.

Returns
-------
value : function
    A function expecting a node as its sole argument. The function will
    returns a value from G.node[u] that depends on `edge_attr`.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="_edge_value"></a>
<div class="private">
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">_edge_value</span>(<span class="sig-arg">G</span>,
        <span class="sig-arg">edge_attr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#_edge_value">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Returns a function that returns a value from G[u][v].

Suppose there exists an edge between u and v.  Then we return a function
expecting u and v as arguments.  For Graph and DiGraph, G[u][v] is 
the edge attribute dictionary, and the function (essentially) returns 
G[u][v][edge_attr].  However, we also handle cases when `edge_attr` is None
and when it is a function itself. For MultiGraph and MultiDiGraph, G[u][v]
is a dictionary of all edges between u and v.  In this case, the returned
function sums the value of `edge_attr` for every edge between u and v.

Parameters
----------
G : graph
   A NetworkX graph 

edge_attr : {None, str, callable}
    Specification of how the value of the edge attribute should be obtained 
    from the edge attribute dictionary, G[u][v].  For multigraphs, G[u][v]
    is a dictionary of all the edges between u and v.  This allows for 
    special treatment of multiedges.

Returns
-------
value : function
    A function expecting two nodes as parameters. The nodes should 
    represent the from- and to- node of an edge. The function will
    return a value from G[u][v] that depends on `edge_attr`.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="attr_matrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">attr_matrix</span>(<span class="sig-arg">G</span>,
        <span class="sig-arg">edge_attr</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">node_attr</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normalized</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">rc_order</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#attr_matrix">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Returns a NumPy matrix using attributes from G.

If only `G` is passed in, then the adjacency matrix is constructed.

Let A be a discrete set of values for the node attribute `node_attr`. Then
the elements of A represent the rows and columns of the constructed matrix.
Now, iterate through every edge e=(u,v) in `G` and consider the value
of the edge attribute `edge_attr`.  If ua and va are the values of the 
node attribute `node_attr` for u and v, respectively, then the value of
the edge attribute is added to the matrix element at (ua, va). 

Parameters
----------
G : graph
    The NetworkX graph used to construct the NumPy matrix.

edge_attr : str, optional
    Each element of the matrix represents a running total of the
    specified edge attribute for edges whose node attributes correspond
    to the rows/cols of the matirx. The attribute must be present for 
    all edges in the graph. If no attribute is specified, then we
    just count the number of edges whose node attributes correspond
    to the matrix element.        

node_attr : str, optional
    Each row and column in the matrix represents a particular value
    of the node attribute.  The attribute must be present for all nodes
    in the graph. Note, the values of this attribute should be reliably
    hashable. So, float values are not recommended. If no attribute is 
    specified, then the rows and columns will be the nodes of the graph.

normalized : bool, optional
    If True, then each row is normalized by the summation of its values.

rc_order : list, optional
    A list of the node attribute values. This list specifies the ordering 
    of rows and columns of the array. If no ordering is provided, then
    the ordering will be random (and also, a return value).

Other Parameters
----------------
dtype : NumPy data-type, optional
    A valid NumPy dtype used to initialize the array. Keep in mind certain
    dtypes can yield unexpected results if the array is to be normalized.
    The parameter is passed to numpy.zeros(). If unspecified, the NumPy
    default is used.

order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory. This parameter is passed to
    numpy.zeros(). If unspecified, the NumPy default is used.

Returns
-------
M : NumPy matrix
    The attribute matrix.

ordering : list
    If `rc_order` was specified, then only the matrix is returned.
    However, if `rc_order` was None, then the ordering used to construct 
    the matrix is returned as well.

Examples
--------
Construct an adjacency matrix:

&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edge(0,1,thickness=1,weight=3)
&gt;&gt;&gt; G.add_edge(0,2,thickness=2)
&gt;&gt;&gt; G.add_edge(1,2,thickness=3)
&gt;&gt;&gt; nx.attr_matrix(G, rc_order=[0,1,2])
matrix([[ 0.,  1.,  1.],
        [ 1.,  0.,  1.],
        [ 1.,  1.,  0.]])

Alternatively, we can obtain the matrix describing edge thickness.

&gt;&gt;&gt; nx.attr_matrix(G, edge_attr='thickness', rc_order=[0,1,2])
matrix([[ 0.,  1.,  2.],
        [ 1.,  0.,  3.],
        [ 2.,  3.,  0.]])

We can also color the nodes and ask for the probability distribution over
all edges (u,v) describing:  
        
    Pr(v has color Y | u has color X)

&gt;&gt;&gt; G.node[0]['color'] = 'red'
&gt;&gt;&gt; G.node[1]['color'] = 'red'
&gt;&gt;&gt; G.node[2]['color'] = 'blue'
&gt;&gt;&gt; rc = ['red', 'blue']
&gt;&gt;&gt; nx.attr_matrix(G, node_attr='color', normalized=True, rc_order=rc)
matrix([[ 0.33333333,  0.66666667],
        [ 1.        ,  0.        ]])

For example, the above tells us that for all edges (u,v):

    Pr( v is red  | u is red)  = 1/3
    Pr( v is blue | u is red)  = 2/3

    Pr( v is red  | u is blue) = 1
    Pr( v is blue | u is blue) = 0

Finally, we can obtain the total weights listed by the node colors.

&gt;&gt;&gt; nx.attr_matrix(G, edge_attr='weight', node_attr='color', rc_order=rc)
matrix([[ 3.,  2.],
        [ 2.,  0.]])

Thus, the total weight over all edges (u,v) with u and v having colors:

    (red, red)   is 3   # the sole contribution is from edge (0,1)
    (red, blue)  is 2   # contributions from edges (0,2) and (1,2)
    (blue, red)  is 2   # same as (red, blue) since graph is undirected
    (blue, blue) is 0   # there are no edges with blue endpoints

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="attr_sparse_matrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">attr_sparse_matrix</span>(<span class="sig-arg">G</span>,
        <span class="sig-arg">edge_attr</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">node_attr</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normalized</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">rc_order</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="networkx.linalg.attrmatrix-pysrc.html#attr_sparse_matrix">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Returns a SciPy sparse matrix using attributes from G.

If only `G` is passed in, then the adjacency matrix is constructed.

Let A be a discrete set of values for the node attribute `node_attr`. Then
the elements of A represent the rows and columns of the constructed matrix.
Now, iterate through every edge e=(u,v) in `G` and consider the value
of the edge attribute `edge_attr`.  If ua and va are the values of the 
node attribute `node_attr` for u and v, respectively, then the value of
the edge attribute is added to the matrix element at (ua, va). 

Parameters
----------
G : graph
    The NetworkX graph used to construct the NumPy matrix.

edge_attr : str, optional
    Each element of the matrix represents a running total of the
    specified edge attribute for edges whose node attributes correspond
    to the rows/cols of the matirx. The attribute must be present for 
    all edges in the graph. If no attribute is specified, then we
    just count the number of edges whose node attributes correspond
    to the matrix element.        

node_attr : str, optional
    Each row and column in the matrix represents a particular value
    of the node attribute.  The attribute must be present for all nodes
    in the graph. Note, the values of this attribute should be reliably
    hashable. So, float values are not recommended. If no attribute is 
    specified, then the rows and columns will be the nodes of the graph.

normalized : bool, optional
    If True, then each row is normalized by the summation of its values.

rc_order : list, optional
    A list of the node attribute values. This list specifies the ordering 
    of rows and columns of the array. If no ordering is provided, then
    the ordering will be random (and also, a return value).

Other Parameters
----------------
dtype : NumPy data-type, optional
    A valid NumPy dtype used to initialize the array. Keep in mind certain
    dtypes can yield unexpected results if the array is to be normalized.
    The parameter is passed to numpy.zeros(). If unspecified, the NumPy
    default is used.

Returns
-------
M : SciPy sparse matrix
    The attribute matrix.

ordering : list
    If `rc_order` was specified, then only the matrix is returned.
    However, if `rc_order` was None, then the ordering used to construct 
    the matrix is returned as well.

Examples
--------
Construct an adjacency matrix:

&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edge(0,1,thickness=1,weight=3)
&gt;&gt;&gt; G.add_edge(0,2,thickness=2)
&gt;&gt;&gt; G.add_edge(1,2,thickness=3)
&gt;&gt;&gt; M = nx.attr_sparse_matrix(G, rc_order=[0,1,2])
&gt;&gt;&gt; M.todense()
matrix([[ 0.,  1.,  1.],
        [ 1.,  0.,  1.],
        [ 1.,  1.,  0.]])

Alternatively, we can obtain the matrix describing edge thickness.

&gt;&gt;&gt; M = nx.attr_sparse_matrix(G, edge_attr='thickness', rc_order=[0,1,2])
&gt;&gt;&gt; M.todense()
matrix([[ 0.,  1.,  2.],
        [ 1.,  0.,  3.],
        [ 2.,  3.,  0.]])

We can also color the nodes and ask for the probability distribution over
all edges (u,v) describing:  
        
    Pr(v has color Y | u has color X)

&gt;&gt;&gt; G.node[0]['color'] = 'red'
&gt;&gt;&gt; G.node[1]['color'] = 'red'
&gt;&gt;&gt; G.node[2]['color'] = 'blue'
&gt;&gt;&gt; rc = ['red', 'blue']
&gt;&gt;&gt; M = nx.attr_sparse_matrix(G, node_attr='color',                                   normalized=True, rc_order=rc)
&gt;&gt;&gt; M.todense()
matrix([[ 0.33333333,  0.66666667],
        [ 1.        ,  0.        ]])

For example, the above tells us that for all edges (u,v):

    Pr( v is red  | u is red)  = 1/3
    Pr( v is blue | u is red)  = 2/3

    Pr( v is red  | u is blue) = 1
    Pr( v is blue | u is blue) = 0

Finally, we can obtain the total weights listed by the node colors.

&gt;&gt;&gt; M = nx.attr_sparse_matrix(G, edge_attr='weight',                                  node_attr='color', rc_order=rc)
&gt;&gt;&gt; M.todense()
matrix([[ 3.,  2.],
        [ 2.,  0.]])

Thus, the total weight over all edges (u,v) with u and v having colors:

    (red, red)   is 3   # the sole contribution is from edge (0,1)
    (red, blue)  is 2   # contributions from edges (0,2) and (1,2)
    (blue, red)  is 2   # same as (red, blue) since graph is undirected
    (blue, blue) is 0   # there are no edges with blue endpoints

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://github.com/jackdreilly/commroute">CommRoute</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Tue Jul 17 15:18:46 2012
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
